import {
  Client
} from "./chunk-FLWYXP5Z.js";
import {
  CARTESIA_VERSION,
  constructApiUrl
} from "./chunk-2BFEKY3F.js";
import {
  base64ToArray,
  createMessageHandlerForContextId,
  getEmitteryCallbacks,
  isSentinel
} from "./chunk-5SBAQNWQ.js";
import {
  Source
} from "./chunk-I5YVYTNK.js";
import {
  __async,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __spreadProps,
  __spreadValues
} from "./chunk-NJDRWDQ3.js";

// src/tts/websocket.ts
import Emittery from "emittery";
import { humanId } from "human-id";
import { WebSocket as PartySocketWebSocket } from "partysocket";
var _isConnected, _sampleRate, _container, _encoding, _WebSocket_instances, generateId_fn;
var WebSocket = class extends Client {
  /**
   * Create a new WebSocket client.
   *
   * @param args - Arguments to pass to the Client constructor.
   */
  constructor({ sampleRate, container, encoding }, ...args) {
    super(...args);
    __privateAdd(this, _WebSocket_instances);
    __privateAdd(this, _isConnected, false);
    __privateAdd(this, _sampleRate);
    __privateAdd(this, _container);
    __privateAdd(this, _encoding);
    __privateSet(this, _sampleRate, sampleRate);
    __privateSet(this, _container, container != null ? container : "raw");
    __privateSet(this, _encoding, encoding != null ? encoding : "pcm_f32le");
  }
  /**
   * Send a message over the WebSocket to start a stream.
   *
   * @param inputs - Generation parameters. Defined in the StreamRequest type.
   * @param options - Options for the stream.
   * @param options.timeout - The maximum time to wait for a chunk before cancelling the stream.
   *                          If set to `0`, the stream will not time out.
   * @returns A Source object that can be passed to a Player to play the audio.
   * @returns An Emittery instance that emits messages from the WebSocket.
   * @returns An abort function that can be called to cancel the stream.
   */
  send(inputs, { timeout = 0 } = {}) {
    var _a, _b, _c, _d;
    if (!__privateGet(this, _isConnected)) {
      throw new Error("Not connected to WebSocket. Call .connect() first.");
    }
    if (!inputs.context_id) {
      inputs.context_id = __privateMethod(this, _WebSocket_instances, generateId_fn).call(this);
    }
    if (!inputs.output_format) {
      inputs.output_format = {
        container: __privateGet(this, _container),
        encoding: __privateGet(this, _encoding),
        sample_rate: __privateGet(this, _sampleRate)
      };
    }
    (_a = this.socket) == null ? void 0 : _a.send(
      JSON.stringify(__spreadValues({}, inputs))
    );
    const emitter = new Emittery();
    const source = new Source({
      sampleRate: __privateGet(this, _sampleRate),
      encoding: __privateGet(this, _encoding),
      container: __privateGet(this, _container)
    });
    const streamCompleteController = new AbortController();
    let timeoutId = null;
    if (timeout > 0) {
      timeoutId = setTimeout(streamCompleteController.abort, timeout);
    }
    const handleMessage = createMessageHandlerForContextId(
      inputs.context_id,
      (_0) => __async(this, [_0], function* ({ chunk, message, data }) {
        emitter.emit("message", message);
        if (data.type === "timestamps") {
          emitter.emit("timestamps", data.word_timestamps);
          return;
        }
        if (isSentinel(chunk)) {
          yield source.close();
          streamCompleteController.abort();
          return;
        }
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(streamCompleteController.abort, timeout);
        }
        if (!chunk) {
          return;
        }
        yield source.enqueue(base64ToArray([chunk], __privateGet(this, _encoding)));
      })
    );
    (_b = this.socket) == null ? void 0 : _b.addEventListener("message", handleMessage, {
      signal: streamCompleteController.signal
    });
    (_c = this.socket) == null ? void 0 : _c.addEventListener(
      "close",
      () => {
        streamCompleteController.abort();
      },
      {
        once: true,
        signal: streamCompleteController.signal
      }
    );
    (_d = this.socket) == null ? void 0 : _d.addEventListener(
      "error",
      () => {
        streamCompleteController.abort();
      },
      {
        once: true,
        signal: streamCompleteController.signal
      }
    );
    streamCompleteController.signal.addEventListener("abort", () => {
      source.close();
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      emitter.clearListeners();
    });
    return __spreadProps(__spreadValues({
      source
    }, getEmitteryCallbacks(emitter)), {
      stop: streamCompleteController.abort.bind(streamCompleteController)
    });
  }
  /**
   * Continue a stream.
   *
   * @param inputs - Generation parameters. Defined in the StreamRequest type, but must include a `context_id` field. `continue` is set to true by default.
   */
  continue(inputs) {
    var _a;
    if (!__privateGet(this, _isConnected)) {
      throw new Error("Not connected to WebSocket. Call .connect() first.");
    }
    if (!inputs.context_id) {
      throw new Error("context_id is required to continue a context.");
    }
    if (!inputs.output_format) {
      inputs.output_format = {
        container: __privateGet(this, _container),
        encoding: __privateGet(this, _encoding),
        sample_rate: __privateGet(this, _sampleRate)
      };
    }
    (_a = this.socket) == null ? void 0 : _a.send(
      JSON.stringify(__spreadValues({
        continue: true
      }, inputs))
    );
  }
  /**
   * Authenticate and connect to a Cartesia streaming WebSocket.
   *
   * @returns A promise that resolves when the WebSocket is connected.
   * @throws {Error} If the WebSocket fails to connect.
   */
  connect() {
    return __async(this, arguments, function* (options = {}) {
      if (__privateGet(this, _isConnected)) {
        throw new Error("WebSocket is already connected.");
      }
      const emitter = new Emittery();
      this.socket = new PartySocketWebSocket(
        () => __async(this, null, function* () {
          const url = constructApiUrl(this.baseUrl, "/tts/websocket", {
            websocket: true
          });
          url.searchParams.set("api_key", yield this.apiKey());
          url.searchParams.set("cartesia_version", CARTESIA_VERSION);
          return url.toString();
        }),
        void 0,
        options
      );
      this.socket.binaryType = "arraybuffer";
      this.socket.onopen = () => {
        __privateSet(this, _isConnected, true);
        emitter.emit("open");
      };
      this.socket.onclose = () => {
        __privateSet(this, _isConnected, false);
        emitter.emit("close");
      };
      return new Promise(
        (resolve, reject) => {
          var _a, _b, _c;
          (_a = this.socket) == null ? void 0 : _a.addEventListener(
            "open",
            () => {
              resolve(getEmitteryCallbacks(emitter));
            },
            {
              once: true
            }
          );
          const aborter = new AbortController();
          (_b = this.socket) == null ? void 0 : _b.addEventListener(
            "error",
            () => {
              aborter.abort();
              reject(new Error("WebSocket failed to connect."));
            },
            {
              signal: aborter.signal
            }
          );
          (_c = this.socket) == null ? void 0 : _c.addEventListener(
            "close",
            () => {
              aborter.abort();
              reject(new Error("WebSocket closed before it could connect."));
            },
            {
              signal: aborter.signal
            }
          );
        }
      );
    });
  }
  /**
   * Disconnect from the Cartesia streaming WebSocket.
   */
  disconnect() {
    var _a;
    (_a = this.socket) == null ? void 0 : _a.close();
  }
};
_isConnected = new WeakMap();
_sampleRate = new WeakMap();
_container = new WeakMap();
_encoding = new WeakMap();
_WebSocket_instances = new WeakSet();
/**
 * Generate a unique ID suitable for a streaming context.
 *
 * Not suitable for security purposes or as a primary key, since
 * it lacks the amount of entropy required for those use cases.
 *
 * @returns A unique ID.
 */
generateId_fn = function() {
  return humanId({
    separator: "-",
    capitalize: false
  });
};

export {
  WebSocket
};
