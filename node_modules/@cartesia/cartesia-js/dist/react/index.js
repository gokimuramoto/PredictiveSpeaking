import {
  Cartesia
} from "../chunk-RYHHRY64.js";
import "../chunk-RJICGVPL.js";
import "../chunk-WLEVU3HN.js";
import {
  pingServer
} from "../chunk-LKKWJLUG.js";
import "../chunk-QT5LHJ3D.js";
import "../chunk-CJZSHIRI.js";
import "../chunk-FLWYXP5Z.js";
import "../chunk-2BFEKY3F.js";
import {
  Player
} from "../chunk-CSOXALSC.js";
import "../chunk-5SBAQNWQ.js";
import "../chunk-I5YVYTNK.js";
import {
  __async
} from "../chunk-NJDRWDQ3.js";

// src/react/index.ts
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
var PING_INTERVAL = 5e3;
var DEFAULT_BUFFER_DURATION = 0.01;
function useTTS({
  apiKey,
  baseUrl,
  sampleRate,
  onError
}) {
  var _a, _b;
  if (typeof window === "undefined") {
    return {
      buffer: () => __async(this, null, function* () {
      }),
      play: () => __async(this, null, function* () {
      }),
      pause: () => __async(this, null, function* () {
      }),
      resume: () => __async(this, null, function* () {
      }),
      toggle: () => __async(this, null, function* () {
      }),
      playbackStatus: "inactive",
      bufferStatus: "inactive",
      isWaiting: false,
      source: null,
      isConnected: false,
      metrics: {
        modelLatency: null
      }
    };
  }
  const websocket = useMemo(() => {
    if (!apiKey) {
      return null;
    }
    const cartesia = new Cartesia({ apiKey, baseUrl });
    baseUrl = baseUrl != null ? baseUrl : cartesia.baseUrl;
    return cartesia.tts.websocket({
      container: "raw",
      encoding: "pcm_f32le",
      sampleRate
    });
  }, [apiKey, baseUrl, sampleRate]);
  const websocketReturn = useRef(null);
  const player = useRef(null);
  const [playbackStatus, setPlaybackStatus] = useState("inactive");
  const [bufferStatus, setBufferStatus] = useState("inactive");
  const [isWaiting, setIsWaiting] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [bufferDuration, setBufferDuration] = useState(null);
  const [messages, setMessages] = useState([]);
  const buffer = useCallback(
    (options) => __async(this, null, function* () {
      var _a2, _b2;
      (_a2 = websocketReturn.current) == null ? void 0 : _a2.stop();
      try {
        setMessages([]);
        setBufferStatus("buffering");
        websocketReturn.current = (_b2 = websocket == null ? void 0 : websocket.send(options)) != null ? _b2 : null;
        if (!websocketReturn.current) {
          return;
        }
        const unsubscribe = websocketReturn.current.on("message", (message) => {
          const parsedMessage = JSON.parse(message);
          setMessages((messages2) => [...messages2, parsedMessage]);
          if (parsedMessage.error) {
            onError == null ? void 0 : onError(new Error(parsedMessage.error));
          }
        });
        yield websocketReturn.current.source.once("close");
        setBufferStatus("buffered");
        unsubscribe();
      } catch (error) {
        if (error instanceof Error) {
          onError == null ? void 0 : onError(error);
        } else {
          console.error(error);
        }
      }
    }),
    [websocket, onError]
  );
  const metrics = useMemo(() => {
    var _a2;
    if (messages.length === 0) {
      return {
        modelLatency: null
      };
    }
    const modelLatency = (_a2 = messages[0].step_time) != null ? _a2 : null;
    return {
      modelLatency: Math.trunc(modelLatency)
    };
  }, [messages]);
  useEffect(() => {
    let cleanup = () => {
    };
    function setupConnection() {
      return __async(this, null, function* () {
        try {
          const connection = yield websocket == null ? void 0 : websocket.connect();
          if (!connection) {
            return;
          }
          const unsubscribes = [];
          setIsConnected(true);
          unsubscribes.push(
            connection.on("open", () => {
              setIsConnected(true);
            })
          );
          unsubscribes.push(
            connection.on("close", () => {
              setIsConnected(false);
            })
          );
          const intervalId = setInterval(() => {
            if (baseUrl) {
              pingServer(new URL(baseUrl).origin).then((ping) => {
                let bufferDuration2;
                if (ping < 300) {
                  bufferDuration2 = 0.01;
                } else if (ping > 1500) {
                  bufferDuration2 = 6;
                } else {
                  bufferDuration2 = ping / 1e3 * 4;
                }
                setBufferDuration(bufferDuration2);
              });
            }
          }, PING_INTERVAL);
          return () => {
            for (const unsubscribe of unsubscribes) {
              unsubscribe();
            }
            clearInterval(intervalId);
            websocket == null ? void 0 : websocket.disconnect();
          };
        } catch (e) {
          console.error(e);
        }
      });
    }
    setupConnection().then((cleanupConnection) => {
      cleanup = cleanupConnection;
    });
    return () => cleanup == null ? void 0 : cleanup();
  }, [websocket, baseUrl]);
  const play = useCallback(() => __async(this, null, function* () {
    try {
      if (playbackStatus === "playing" || !websocketReturn.current) {
        return;
      }
      if (player.current) {
        yield player.current.stop();
      }
      if (playbackStatus === "finished") {
        websocketReturn.current.source.seek(0, "start");
      }
      setPlaybackStatus("playing");
      const unsubscribes = [];
      unsubscribes.push(
        websocketReturn.current.source.on("wait", () => {
          setIsWaiting(true);
        })
      );
      unsubscribes.push(
        websocketReturn.current.source.on("read", () => {
          setIsWaiting(false);
        })
      );
      player.current = new Player({
        bufferDuration: bufferDuration != null ? bufferDuration : DEFAULT_BUFFER_DURATION
      });
      yield player.current.play(websocketReturn.current.source);
      for (const unsubscribe of unsubscribes) {
        unsubscribe();
      }
      setPlaybackStatus("finished");
    } catch (error) {
      if (error instanceof Error) {
        onError == null ? void 0 : onError(error);
      } else {
        console.error(error);
      }
    }
  }), [playbackStatus, bufferDuration, onError]);
  const pause = useCallback(() => __async(this, null, function* () {
    var _a2;
    try {
      yield (_a2 = player.current) == null ? void 0 : _a2.pause();
      setPlaybackStatus("paused");
    } catch (error) {
      if (error instanceof Error) {
        onError == null ? void 0 : onError(error);
      } else {
        console.error(error);
      }
    }
  }), [onError]);
  const resume = useCallback(() => __async(this, null, function* () {
    var _a2;
    try {
      yield (_a2 = player.current) == null ? void 0 : _a2.resume();
      setPlaybackStatus("playing");
    } catch (error) {
      if (error instanceof Error) {
        onError == null ? void 0 : onError(error);
      } else {
        console.error(error);
      }
    }
  }), [onError]);
  const toggle = useCallback(() => __async(this, null, function* () {
    var _a2;
    try {
      yield (_a2 = player.current) == null ? void 0 : _a2.toggle();
      setPlaybackStatus((status) => {
        if (status === "playing") {
          return "paused";
        }
        if (status === "paused") {
          return "playing";
        }
        return status;
      });
    } catch (error) {
      if (error instanceof Error) {
        onError == null ? void 0 : onError(error);
      } else {
        console.error(error);
      }
    }
  }), [onError]);
  return {
    buffer,
    play,
    pause,
    source: (_b = (_a = websocketReturn.current) == null ? void 0 : _a.source) != null ? _b : null,
    resume,
    toggle,
    playbackStatus,
    bufferStatus,
    isWaiting,
    isConnected,
    metrics
  };
}
export {
  useTTS
};
